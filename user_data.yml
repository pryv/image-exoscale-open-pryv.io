#cloud-config
write_files:
- content: |
    network:
      version: 2
      renderer: networkd
      ethernets:
        lo:
          match:
            name: lo
          addresses:
          - ${IP_ADDRESS}/32
  path: /etc/netplan/51-eip.yaml
- content: |
    upstream core_server {
      # api hostfrom docker compose and max_fails , should be changed for production OVERRIDE ME
      server localhost:3000 max_fails=10 fail_timeout=30s;
      }

    upstream websocket_server {
      #  api hostfrom docker compose and max_fails , should be changed for production OVERRIDE ME
      server localhost:3000 max_fails=10 fail_timeout=30s;
    }

    # API (Core)
    server {
    # redirect from http to https
      listen 80 default_server;
      server_name ${DOMAIN};

      location /.well-known/acme-challenge/ {
        root /var/www/certbot;
      }
      location / {
        return 301 https://$host$request_uri;
      }
    }

    server {
      # redirect from www to without www
      server_name www.${DOMAIN};
      return 301 $scheme://${DOMAIN}$request_uri;
    }

    server {
      listen               443 ssl;

      # set server name from env variables (set in docker compose)
      server_name          ${DOMAIN};

      client_max_body_size 20M;

      ### Proxy options (has to be within server definition to be effective)
      # This enables websocket support
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_set_header X-Real-IP  $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto https;
      proxy_redirect   off;
      proxy_buffering off;
      proxy_buffers 16 8k;
      # User information will be in the host, so proxy that as well.
      set $my_host      $http_host;
      proxy_set_header  Host $my_host;

      location / {
        proxy_pass http://core_server;
      }

      # Socket.IO: Handshakes will be done against a specific backend
      # process and will not be valid on other backend processes. We cannot load 
      # balance this the same way as other calls. 
      location /socket.io/ {
        proxy_pass http://websocket_server;
      }
    }
  path: /etc/nginx/sites-enabled/default
- content: |
    {
      "openSource": {
        "isActive": true
      },
      "dnsLess": {
        "isActive": true,
        "publicUrl": "https://${DOMAIN}"
      },
      "http": {
        "port": 3000,
        "ip": "127.0.0.1"
      },
      "auth": {
        "adminAccessKey": "${RANDOM_KEY}",
        "trustedApps": "*@https://pryv.github.io*, *@https://*${DOMAIN}*"
      },
      "eventFiles": {
        "attachmentsDirPath": "var-pryv/attachment-files"
      },
      "service": {
        "name": "Open-Pryv.io",
        "support": "https://pryv.com/open-pryv-non-configured-page/",
        "terms": "https://pryv.com/open-pryv-non-configured-page/",
        "home": "https://pryv.com/open-pryv-non-configured-page/",
        "eventTypes": "https://api.pryv.com/event-types/flat.json"
      },
      "services": {
        "email": {
          "enabled": {
            "welcome": true,
            "resetPassword": true
          }
        }
      }
    }
  path: /home/ubuntu/config.json



runcmd:
 - netplan apply
 - git -C /home/ubuntu/open-pryv.io/ pull
 - mv /home/ubuntu/config.json /home/ubuntu/open-pryv.io/config.json
 - while ! ping -q -c 1 ${IP_ADDRESS} >/dev/null ; do sleep 1; done ;
 - certbot --nginx -n --email ${EMAIL} --agree-tos -d ${DOMAIN}
 - yes | yarn --cwd /home/ubuntu/open-pryv.io setup
 - yes | yarn --cwd /home/ubuntu/open-pryv.io release
 - yes | yarn --cwd /home/ubuntu/open-pryv.io pryv&
 - systemctl retart nginx
 - echo "0 1 * * * root certbot renew" >> /etc/crontab